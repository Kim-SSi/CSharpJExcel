using System;

// Port to C# 
// Chris Laforet
// Wachovia, a Wells-Fargo Company
// Feb 2010

using System.Collections.Generic;
using System.Text;
using System.IO;


namespace CSharpJExcel.Jxl.Biff.Formula
	{
	/**
	 * This class is a scanner generated by 
	 * <a href="http://www.jflex.de/">JFlex</a> 1.4.1
	 * on 24/10/09 14:10 from the specification file
	 * <tt>xlformula.flex</tt>
	 */
	/* The following code was generated by JFlex 1.4.1 on 24/10/09 14:10 */
	sealed class Yylex
		{

		/** This character denotes the end of file */
		public const int YYEOF = -1;

		/** initial size of the lookahead buffer */
		private const int ZZ_BUFFERSIZE = 16384;

		/** lexical states */
		public const int YYSTRING = 1;
		public const int YYINITIAL = 0;

		/** 
		 * Translates characters to character classes
		 */
		private const string ZZ_CMAP_PACKED =
			  "\u0008\u0000\u0003\u0015\u0015\u0000\u0001\u0015\u0001\u0014\u0001\u0011\u0001\u0016\u0001\u0008" +
			  "\u0002\u0000\u0001\u0012\u0001\u0005\u0001\u0006\u0001\u0021\u0001\u001f\u0001\u0004\u0001\u0020" +
			  "\u0001\u0007\u0001\u001b\u0001\u001c\u0009\u0002\u0001\u0003\u0001\u0000\u0001\u0024\u0001\u0023" +
			  "\u0001\u0022\u0001\u001e\u0001\u0000\u0001\u000e\u0002\u0001\u0001\u0018\u0001\u000c\u0001\u000d" +
			  "\u0002\u0001\u0001\u0019\u0002\u0001\u0001\u000f\u0001\u001d\u0001\u0017\u0003\u0001\u0001\u000a" +
			  "\u0001\u0010\u0001\u0009\u0001\u000b\u0001\u001a\u0004\u0001\u0004\u0000\u0001\u0013\u0001\u0000" +
			  "\u001a\u0001\uff85\u0000";

		/** 
		 * Translates characters to character classes
		 */
		private static readonly char[] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);

		/** 
		 * Translates DFA states to action switch labels.
		 */
		private static readonly int[] ZZ_ACTION = zzUnpackAction();

		private const string ZZ_ACTION_PACKED_0 =
			  "\u0001\u0000\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001\u0005\u0001\u0006\u0001\u0007" +
			  "\u0001\u0000\u0002\u0002\u0001\u0008\u0001\u0000\u0001\u0009\u0001\u0000\u0001\u000a\u0001\u000b" +
			  "\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f\u0001\u0010\u0001\u0001\u0001\u0011\u0001\u0002" +
			  "\u0001\u0012\u0001\u0000\u0001\u0013\u0001\u0000\u0001\u0002\u0003\u0000\u0002\u0002\u0005\u0000" +
			  "\u0001\u0014\u0001\u0015\u0001\u0016\u0001\u0002\u0001\u0000\u0001\u0017\u0001\u0000\u0001\u0012" +
			  "\u0002\u0000\u0001\u0018\u0001\u0000\u0002\u0002\u0008\u0000\u0001\u0017\u0001\u0000\u0001\u0019" +
			  "\u0001\u0000\u0001\u001a\u0008\u0000\u0001\u001b\u0002\u0000\u0001\u0019\u0002\u0000\u0001\u001c" +
			  "\u0004\u0000\u0001\u001d\u0003\u0000\u0001\u001d\u0001\u0000\u0001\u001e\u0001\u0000";

		private static int[] zzUnpackAction()
			{
			int[] result = new int[94];
			int offset = 0;
			offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
			return result;
			}

		private static int zzUnpackAction(string packed, int offset, int[] result)
			{
			int i = 0;       /* index in packed string  */
			int j = offset;  /* index in unpacked array */
			int l = packed.Length;
			while (i < l)
				{
				int count = packed[i++];
				int value = packed[i++];
				do
					{
					result[j++] = value;
					}
				while (--count > 0);
				}
			return j;
			}


		/** 
		 * Translates a state to a row index in the transition table
		 */
		private static readonly int[] ZZ_ROWMAP = zzUnpackRowMap();

		private const string ZZ_ROWMAP_PACKED_0 =
			  "\u0000\u0000\u0000\u0025\u0000\u004a\u0000\u006f\u0000\u0094\u0000\u0094\u0000\u0094\u0000\u0094" +
			  "\u0000\u00b9\u0000\u00de\u0000\u0103\u0000\u0094\u0000\u0128\u0000\u0094\u0000\u014d\u0000\u0094" +
			  "\u0000\u0094\u0000\u0094\u0000\u0094\u0000\u0172\u0000\u0094\u0000\u0197\u0000\u01bc\u0000\u0094" +
			  "\u0000\u01e1\u0000\u0206\u0000\u022b\u0000\u0094\u0000\u0250\u0000\u0275\u0000\u029a\u0000\u02bf" +
			  "\u0000\u02e4\u0000\u0309\u0000\u032e\u0000\u0353\u0000\u0378\u0000\u039d\u0000\u03c2\u0000\u03e7" +
			  "\u0000\u0094\u0000\u0094\u0000\u0094\u0000\u040c\u0000\u0431\u0000\u0456\u0000\u047b\u0000\u04a0" +
			  "\u0000\u04c5\u0000\u04ea\u0000\u02bf\u0000\u050f\u0000\u0534\u0000\u0559\u0000\u057e\u0000\u05a3" +
			  "\u0000\u05c8\u0000\u05ed\u0000\u0612\u0000\u0637\u0000\u065c\u0000\u0681\u0000\u0094\u0000\u06a6" +
			  "\u0000\u06cb\u0000\u06cb\u0000\u040c\u0000\u06f0\u0000\u0715\u0000\u073a\u0000\u075f\u0000\u0784" +
			  "\u0000\u07a9\u0000\u07ce\u0000\u07f3\u0000\u0818\u0000\u0818\u0000\u083d\u0000\u0862\u0000\u0887" +
			  "\u0000\u08ac\u0000\u0094\u0000\u08d1\u0000\u08f6\u0000\u091b\u0000\u0940\u0000\u0965\u0000\u098a" +
			  "\u0000\u09af\u0000\u09d4\u0000\u0094\u0000\u09f9\u0000\u0a1e\u0000\u0a1e";

		private static int[] zzUnpackRowMap()
			{
			int[] result = new int[94];
			int offset = 0;
			offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
			return result;
			}

		private static int zzUnpackRowMap(string packed, int offset, int[] result)
			{
			int i = 0;  /* index in packed string  */
			int j = offset;  /* index in unpacked array */
			int l = packed.Length;
			while (i < l)
				{
				int high = (int)packed[i++] << 16;
				result[j++] = high | (int)packed[i++];
				}
			return j;
			}

		/** 
		 * The transition table of the DFA
		 */
		private static readonly int[] ZZ_TRANS = zzUnpackTrans();

		private const string ZZ_TRANS_PACKED_0 =
			  "\u0001\u0000\u0001\u0003\u0001\u0004\u0001\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0000" +
			  "\u0001\u0009\u0001\u000a\u0003\u0003\u0001\u000b\u0003\u0003\u0001\u000c\u0001\u000d\u0002\u0000" +
			  "\u0001\u000e\u0001\u000f\u0004\u0003\u0001\u0010\u0001\u0004\u0001\u0003\u0001\u0000\u0001\u0011" +
			  "\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001\u0016\u0011\u0017\u0001\u0018\u0013\u0017" +
			  "\u0001\u0000\u0001\u0019\u0001\u001a\u0001\u001b\u0001\u0000\u0001\u001c\u0002\u0000\u0001\u001d" +
			  "\u0008\u0019\u0002\u0000\u0001\u001e\u0001\u001f\u0002\u0000\u0004\u0019\u0001\u0000\u0001\u001a" +
			  "\u0001\u0019\u0009\u0000\u0001\u0004\u0004\u0000\u0001\u0020\u0014\u0000\u0001\u0004\u002e\u0000" +
			  "\u0001\u0021\u0007\u0000\u0008\u0021\u0006\u0000\u0004\u0021\u0002\u0000\u0001\u0021\u0008\u0000" +
			  "\u0001\u0019\u0001\u001a\u0001\u001b\u0001\u0000\u0001\u001c\u0002\u0000\u0001\u001d\u0001\u0019" +
			  "\u0001\u0022\u0006\u0019\u0002\u0000\u0001\u001e\u0001\u001f\u0002\u0000\u0004\u0019\u0001\u0000" +
			  "\u0001\u001a\u0001\u0019\u0008\u0000\u0001\u0019\u0001\u001a\u0001\u001b\u0001\u0000\u0001\u001c" +
			  "\u0002\u0000\u0001\u001d\u0005\u0019\u0001\u0023\u0002\u0019\u0002\u0000\u0001\u001e\u0001\u001f" +
			  "\u0002\u0000\u0004\u0019\u0001\u0000\u0001\u001a\u0001\u0019\u0007\u0000\u0012\u000d\u0001\u0024" +
			  "\u0012\u000d\u000a\u0000\u0001\u0025\u000c\u0000\u0001\u0026\u0001\u0027\u0001\u0000\u0001\u0028" +
			  "\u002d\u0000\u0001\u0029\u0023\u0000\u0001\u002a\u0001\u002b\u0001\u0000\u0011\u0017\u0001\u0000" +
			  "\u0013\u0017\u0001\u0000\u0001\u002c\u0001\u001a\u0001\u001b\u0001\u0000\u0001\u001c\u0002\u0000" +
			  "\u0001\u001d\u0008\u002c\u0002\u0000\u0001\u001e\u0001\u001f\u0002\u0000\u0004\u002c\u0001\u0000" +
			  "\u0001\u001a\u0001\u002c\u0008\u0000\u0001\u001e\u0001\u001a\u0001\u002d\u0005\u0000\u0008\u001e" +
			  "\u0002\u0000\u0001\u001e\u0003\u0000\u0004\u001e\u0001\u0000\u0001\u001a\u0001\u001e\u0008\u0000" +
			  "\u0001\u002e\u0006\u0000\u0001\u002f\u0008\u002e\u0006\u0000\u0004\u002e\u0002\u0000\u0001\u002e" +
			  "\u0009\u0000\u0001\u0030\u0019\u0000\u0001\u0030\u0009\u0000\u0002\u001e\u0006\u0000\u0008\u001e" +
			  "\u0002\u0000\u0001\u001e\u0003\u0000\u0004\u001e\u0001\u0000\u0002\u001e\u0008\u0000\u0001\u0031" +
			  "\u0006\u0000\u0001\u0032\u0008\u0031\u0006\u0000\u0004\u0031\u0002\u0000\u0001\u0031\u0009\u0000" +
			  "\u0001\u0033\u0019\u0000\u0001\u0033\u0009\u0000\u0001\u0034\u0001\u0030\u0001\u001b\u0004\u0000" +
			  "\u0001\u001d\u0008\u0034\u0006\u0000\u0004\u0034\u0001\u0000\u0001\u0030\u0001\u0034\u0008\u0000" +
			  "\u0001\u002c\u0001\u001a\u0001\u001b\u0001\u0000\u0001\u001c\u0002\u0000\u0001\u001d\u0002\u002c" +
			  "\u0001\u0035\u0005\u002c\u0002\u0000\u0001\u001e\u0001\u001f\u0002\u0000\u0004\u002c\u0001\u0000" +
			  "\u0001\u001a\u0001\u002c\u0008\u0000\u0001\u002c\u0001\u001a\u0001\u001b\u0001\u0000\u0001\u001c" +
			  "\u0002\u0000\u0001\u001d\u0006\u002c\u0001\u0036\u0001\u002c\u0002\u0000\u0001\u001e\u0001\u001f" +
			  "\u0002\u0000\u0004\u002c\u0001\u0000\u0001\u001a\u0001\u002c\u001b\u0000\u0001\u0037\u001c\u0000" +
			  "\u0001\u0038\u0023\u0000\u0001\u0039\u0002\u0000\u0001\u003a\u002f\u0000\u0001\u003b\u0019\u0000" +
			  "\u0001\u003c\u0017\u0000\u0001\u002c\u0001\u001e\u0002\u0000\u0001\u001c\u0003\u0000\u0008\u002c" +
			  "\u0002\u0000\u0001\u001e\u0001\u001f\u0002\u0000\u0004\u002c\u0001\u0000\u0001\u001e\u0001\u002c" +
			  "\u0008\u0000\u0001\u003d\u0006\u0000\u0001\u003e\u0008\u003d\u0006\u0000\u0004\u003d\u0002\u0000" +
			  "\u0001\u003d\u0008\u0000\u0001\u003f\u0007\u0000\u0008\u003f\u0006\u0000\u0004\u003f\u0002\u0000" +
			  "\u0001\u003f\u0008\u0000\u0001\u002e\u0007\u0000\u0008\u002e\u0006\u0000\u0004\u002e\u0002\u0000" +
			  "\u0001\u002e\u0009\u0000\u0001\u0030\u0001\u002d\u0018\u0000\u0001\u0030\u0009\u0000\u0001\u0040" +
			  "\u0001\u0041\u0005\u0000\u0001\u0042\u0008\u0040\u0006\u0000\u0004\u0040\u0001\u0000\u0001\u0041" +
			  "\u0001\u0040\u0008\u0000\u0001\u0031\u0007\u0000\u0008\u0031\u0006\u0000\u0004\u0031\u0002\u0000" +
			  "\u0001\u0031\u0009\u0000\u0001\u0030\u0001\u001b\u0004\u0000\u0001\u001d\u0013\u0000\u0001\u0030" +
			  "\u0009\u0000\u0001\u002c\u0001\u001e\u0002\u0000\u0001\u001c\u0003\u0000\u0003\u002c\u0001\u0043" +
			  "\u0004\u002c\u0002\u0000\u0001\u001e\u0001\u001f\u0002\u0000\u0004\u002c\u0001\u0000\u0001\u001e" +
			  "\u0001\u002c\u0008\u0000\u0001\u002c\u0001\u001e\u0002\u0000\u0001\u001c\u0003\u0000\u0007\u002c" +
			  "\u0001\u0035\u0002\u0000\u0001\u001e\u0001\u001f\u0002\u0000\u0004\u002c\u0001\u0000\u0001\u001e" +
			  "\u0001\u002c\u0008\u0000\u0001\u0044\u0006\u0000\u0001\u0045\u0008\u0044\u0006\u0000\u0004\u0044" +
			  "\u0002\u0000\u0001\u0044\u0014\u0000\u0001\u0046\u0026\u0000\u0001\u0047\u000d\u0000\u0001\u0046" +
			  "\u0024\u0000\u0001\u0048\u0021\u0000\u0001\u0049\u0019\u0000\u0001\u004a\u0016\u0000\u0001\u004b" +
			  "\u0001\u004c\u0005\u0000\u0001\u004d\u0008\u004b\u0006\u0000\u0004\u004b\u0001\u0000\u0001\u004c" +
			  "\u0001\u004b\u0008\u0000\u0001\u003d\u0007\u0000\u0008\u003d\u0006\u0000\u0004\u003d\u0002\u0000" +
			  "\u0001\u003d\u0009\u0000\u0001\u0041\u0005\u0000\u0001\u0042\u0013\u0000\u0001\u0041\u000a\u0000" +
			  "\u0001\u0041\u0019\u0000\u0001\u0041\u0009\u0000\u0001\u004e\u0001\u004f\u0001\u0050\u0004\u0000" +
			  "\u0001\u0051\u0008\u004e\u0006\u0000\u0004\u004e\u0001\u0000\u0001\u004f\u0001\u004e\u0008\u0000" +
			  "\u0001\u0044\u0007\u0000\u0008\u0044\u0006\u0000\u0004\u0044\u0002\u0000\u0001\u0044\u001b\u0000" +
			  "\u0001\u0052\u001f\u0000\u0001\u0046\u0021\u0000\u0001\u0053\u0033\u0000\u0001\u0054\u0014\u0000" +
			  "\u0001\u0055\u001b\u0000\u0001\u004c\u0005\u0000\u0001\u004d\u0013\u0000\u0001\u004c\u000a\u0000" +
			  "\u0001\u004c\u0019\u0000\u0001\u004c\u000a\u0000\u0001\u004f\u0001\u0050\u0004\u0000\u0001\u0051" +
			  "\u0013\u0000\u0001\u004f\u000a\u0000\u0001\u004f\u0001\u0056\u0018\u0000\u0001\u004f\u0009\u0000" +
			  "\u0001\u0057\u0006\u0000\u0001\u0058\u0008\u0057\u0006\u0000\u0004\u0057\u0002\u0000\u0001\u0057" +
			  "\u0009\u0000\u0001\u004f\u0019\u0000\u0001\u004f\u0026\u0000\u0001\u0052\u0022\u0000\u0001\u0046" +
			  "\u0014\u0000\u0001\u0046\u0019\u0000\u0001\u0059\u0006\u0000\u0001\u005a\u0008\u0059\u0006\u0000" +
			  "\u0004\u0059\u0002\u0000\u0001\u0059\u0008\u0000\u0001\u005b\u0007\u0000\u0008\u005b\u0006\u0000" +
			  "\u0004\u005b\u0002\u0000\u0001\u005b\u0008\u0000\u0001\u0057\u0007\u0000\u0008\u0057\u0006\u0000" +
			  "\u0004\u0057\u0002\u0000\u0001\u0057\u0008\u0000\u0001\u005c\u0001\u005d\u0005\u0000\u0001\u005e" +
			  "\u0008\u005c\u0006\u0000\u0004\u005c\u0001\u0000\u0001\u005d\u0001\u005c\u0008\u0000\u0001\u0059" +
			  "\u0007\u0000\u0008\u0059\u0006\u0000\u0004\u0059\u0002\u0000\u0001\u0059\u0009\u0000\u0001\u005d" +
			  "\u0005\u0000\u0001\u005e\u0013\u0000\u0001\u005d\u000a\u0000\u0001\u005d\u0019\u0000\u0001\u005d" +
			  "\u0008\u0000";

		private static int[] zzUnpackTrans()
			{
			int[] result = new int[2627];
			int offset = 0;
			offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
			return result;
			}

		private static int zzUnpackTrans(string packed, int offset, int[] result)
			{
			int i = 0;       /* index in packed string  */
			int j = offset;  /* index in unpacked array */
			int l = packed.Length;
			while (i < l)
				{
				int count = packed[i++];
				int value = packed[i++];
				value--;
				do 
					{
					result[j++] = value; 
					}
				while (--count > 0);
				}
			return j;
			}


		/* error codes */
		private const int ZZ_UNKNOWN_ERROR = 0;
		private const int ZZ_NO_MATCH = 1;
		private const int ZZ_PUSHBACK_2BIG = 2;

		/* error messages for the codes above */
		private static readonly string[] ZZ_ERROR_MSG = 
				{
				"Unknown internal scanner error",
				"Error: could not match input",
				"Error: pushback value was too large"
				};

		/**
		 * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
		 */
		private static readonly int[] ZZ_ATTRIBUTE = zzUnpackAttribute();

		private const string ZZ_ATTRIBUTE_PACKED_0 =
			  "\u0001\u0000\u0003\u0001\u0004\u0009\u0001\u0000\u0002\u0001\u0001\u0009\u0001\u0000\u0001\u0009" +
			  "\u0001\u0000\u0004\u0009\u0001\u0001\u0001\u0009\u0002\u0001\u0001\u0009\u0002\u0001\u0001\u0000" +
			  "\u0001\u0009\u0001\u0000\u0001\u0001\u0003\u0000\u0002\u0001\u0005\u0000\u0003\u0009\u0001\u0001" +
			  "\u0001\u0000\u0001\u0001\u0001\u0000\u0001\u0001\u0002\u0000\u0001\u0001\u0001\u0000\u0002\u0001" +
			  "\u0008\u0000\u0001\u0009\u0001\u0000\u0001\u0001\u0001\u0000\u0001\u0001\u0008\u0000\u0001\u0001" +
			  "\u0002\u0000\u0001\u0001\u0002\u0000\u0001\u0009\u0004\u0000\u0001\u0001\u0003\u0000\u0001\u0009" +
			  "\u0001\u0000\u0001\u0001\u0001\u0000";

		private static int[] zzUnpackAttribute()
			{
			int[] result = new int[94];
			int offset = 0;
			offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
			return result;
			}

		private static int zzUnpackAttribute(string packed, int offset, int[] result)
			{
			int i = 0;       /* index in packed string  */
			int j = offset;  /* index in unpacked array */
			int l = packed.Length;
			while (i < l)
				{
				int count = packed[i++];
				int value = packed[i++];
				do
					{
					result[j++] = value;
					}
				while (--count > 0);
				}
			return j;
			}

		/** the input device */
		private StreamReader zzReader;

		/** the current state of the DFA */
		private int zzState;

		/** the current lexical state */
		private int zzLexicalState = YYINITIAL;

		/** this buffer contains the current text to be matched and is
			the source of the yytext() string */
		private char[] zzBuffer = new char[ZZ_BUFFERSIZE];

		/** the textposition at the last accepting state */
		private int zzMarkedPos;

		/** the textposition at the last state to be included in yytext */
		private int zzPushbackPos;

		/** the current text position in the buffer */
		private int zzCurrentPos;

		/** startRead marks the beginning of the yytext() string in the buffer */
		private int zzStartRead;

		/** endRead marks the last character in the buffer, that has been read
			from input */
		private int zzEndRead;

		/** number of newlines encountered up to the start of the matched text */
		private int yyline;

		/** the number of characters up to the start of the matched text */
		private int yychar;

		/**
		 * the number of characters from the last newline up to the start of the 
		 * matched text
		 */
		private int yycolumn;

		/** 
		 * zzAtBOL == true <=> the scanner is currently at the beginning of a line
		 */
		private bool zzAtBOL = true;

		/** zzAtEOF == true <=> the scanner is at the EOF */
		private bool zzAtEOF;

		/* user code: */
		public int getPos() 
			{ 
			return yychar; 
			}

		private bool emptyString;
		private ExternalSheet externalSheet;
		private WorkbookMethods nameTable;

		public void setExternalSheet(ExternalSheet es)
			{
			externalSheet = es;
			}

		public void setNameTable(WorkbookMethods nt)
			{
			nameTable = nt;
			}


		/**
		 * Creates a new scanner
		 * There is also a java.io.InputStream version of this constructor.
		 *
		 * @param   in  the java.io.Reader to read input from.
		 */
		public Yylex(StreamReader file)
			{
			this.zzReader = file;
			}

		/**
		 * Creates a new scanner.
		 * There is also java.io.Reader version of this constructor.
		 *
		 * @param   in  the java.io.Inputstream to read input from.
		 */
		public Yylex(Stream file)
			: this(new StreamReader(file))
			{
			}


		/** 
		 * Unpacks the compressed character translation table.
		 *
		 * @param packed   the packed character translation table
		 * @return         the unpacked character translation table
		 */
		private static char[] zzUnpackCMap(string packed)
			{
			char[] map = new char[0x10000];
			int i = 0;  /* index in packed string  */
			int j = 0;  /* index in unpacked array */
			while (i < 100)
				{
				int count = packed[i++];
				char value = packed[i++];
				do
					{
					map[j++] = value;
					}
				while (--count > 0);
				}
			return map;
			}


		/**
		 * Refills the input buffer.
		 *
		 * @return      <code>false</code>, iff there was new input.
		 * 
		 * @exception   java.io.IOException  if any I/O-Error occurs
		 */
		private bool zzRefill()
			{

			/* first: make room (if you can) */
			if (zzStartRead > 0)
				{
				Array.Copy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead - zzStartRead);

				/* translate stored positions */
				zzEndRead -= zzStartRead;
				zzCurrentPos -= zzStartRead;
				zzMarkedPos -= zzStartRead;
				zzPushbackPos -= zzStartRead;
				zzStartRead = 0;
				}

			/* is the buffer big enough? */
			if (zzCurrentPos >= zzBuffer.Length)
				{
				/* if not: blow it up */
				char[] newBuffer = new char[zzCurrentPos * 2];
				Array.Copy(zzBuffer, 0, newBuffer, 0, zzBuffer.Length);
				zzBuffer = newBuffer;
				}

			/* finally: fill the buffer with new input */
			int numRead = zzReader.Read(zzBuffer, zzEndRead, zzBuffer.Length - zzEndRead);

			if (numRead <= 0)
				return true;
			else
				{
				zzEndRead += numRead;
				return false;
				}
			}


		/**
		 * Closes the input stream.
		 */
		public void yyclose()
			{
			zzAtEOF = true;            /* indicate end of file */
			zzEndRead = zzStartRead;  /* invalidate buffer    */

			if (zzReader != null)
				zzReader.Close();
			}


		/**
		 * Resets the scanner to read from a new input stream.
		 * Does not close the old reader.
		 *
		 * All internal variables are reset, the old input stream 
		 * <b>cannot</b> be reused (internal buffer is discarded and lost).
		 * Lexical state is set to <tt>ZZ_INITIAL</tt>.
		 *
		 * @param reader   the new input stream 
		 */
		public void yyreset(StreamReader reader)
			{
			zzReader = reader;
			zzAtBOL = true;
			zzAtEOF = false;
			zzEndRead = zzStartRead = 0;
			zzCurrentPos = zzMarkedPos = zzPushbackPos = 0;
			yyline = yychar = yycolumn = 0;
			zzLexicalState = YYINITIAL;
			}


		/**
		 * Returns the current lexical state.
		 */
		public int yystate()
			{
			return zzLexicalState;
			}


		/**
		 * Enters a new lexical state
		 *
		 * @param newState the new lexical state
		 */
		public void yybegin(int newState)
			{
			zzLexicalState = newState;
			}


		/**
		 * Returns the text matched by the current regular expression.
		 */
		public string yytext()
			{
			return new string(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);
			}


		/**
		 * Returns the character at position <tt>pos</tt> from the 
		 * matched text. 
		 * 
		 * It is equivalent to yytext().charAt(pos), but faster
		 *
		 * @param pos the position of the character to fetch. 
		 *            A value from 0 to yylength()-1.
		 *
		 * @return the character at position pos
		 */
		public char yycharat(int pos)
			{
			return zzBuffer[zzStartRead + pos];
			}


		/**
		 * Returns the length of the matched text region.
		 */
		public int yylength()
			{
			return zzMarkedPos - zzStartRead;
			}


		/**
		 * Reports an error that occured while scanning.
		 *
		 * In a wellformed scanner (no or only correct usage of 
		 * yypushback(int) and a match-all fallback rule) this method 
		 * will only be called with things that "Can't Possibly Happen".
		 * If this method is called, something is seriously wrong
		 * (e.g. a JFlex bug producing a faulty scanner etc.).
		 *
		 * Usual syntax/scanner level error handling should be done
		 * in error fallback rules.
		 *
		 * @param   errorCode  the code of the errormessage to display
		 */
		private void zzScanError(int errorCode)
			{
			string message;
			try
				{
				message = ZZ_ERROR_MSG[errorCode];
				}
			catch (IndexOutOfRangeException e)
				{
				message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
				}

			throw new Exception(message);
			}


		/**
		 * Pushes the specified amount of characters back into the input stream.
		 *
		 * They will be read again by then next call of the scanning method
		 *
		 * @param number  the number of characters to be read again.
		 *                This number must not be greater than yylength()!
		 */
		public void yypushback(int number)
			{
			if (number > yylength())
				zzScanError(ZZ_PUSHBACK_2BIG);

			zzMarkedPos -= number;
			}


		/**
		 * Resumes scanning until the next regular expression is matched,
		 * the end of input is encountered or an I/O-Error occurs.
		 *
		 * @return      the next token
		 * @exception   java.io.IOException  if any I/O-Error occurs
		 */
		public ParseItem yylex()
			{
			int zzInput;
			int zzAction;

			// cached fields:
			int zzCurrentPosL;
			int zzMarkedPosL;
			int zzEndReadL = zzEndRead;
			char[] zzBufferL = zzBuffer;
			char[] zzCMapL = ZZ_CMAP;

			int[] zzTransL = ZZ_TRANS;
			int[] zzRowMapL = ZZ_ROWMAP;
			int[] zzAttrL = ZZ_ATTRIBUTE;

			while (true)
				{
				zzMarkedPosL = zzMarkedPos;

				yychar += zzMarkedPosL - zzStartRead;

				bool zzR = false;
				for (zzCurrentPosL = zzStartRead; zzCurrentPosL < zzMarkedPosL;
																	   zzCurrentPosL++)
					{
					switch (zzBufferL[zzCurrentPosL])
						{
						case '\u000B':
						case '\u000C':
						case '\u0085':
						case '\u2028':
						case '\u2029':
							yyline++;
							zzR = false;
							break;
						case '\r':
							yyline++;
							zzR = true;
							break;
						case '\n':
							if (zzR)
								zzR = false;
							else
								yyline++;
							break;
						default:
							zzR = false;
							break;
						}
					}

				if (zzR)
					{
					// peek one character ahead if it is \n (if we have counted one line too much)
					bool zzPeek;
					if (zzMarkedPosL < zzEndReadL)
						zzPeek = zzBufferL[zzMarkedPosL] == '\n';
					else if (zzAtEOF)
						zzPeek = false;
					else
						{
						bool eof = zzRefill();
						zzEndReadL = zzEndRead;
						zzMarkedPosL = zzMarkedPos;
						zzBufferL = zzBuffer;
						if (eof)
							zzPeek = false;
						else
							zzPeek = zzBufferL[zzMarkedPosL] == '\n';
						}
					if (zzPeek) 
						yyline--;
					}
				zzAction = -1;
				zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
				zzState = zzLexicalState;

				while (true)
					{
					if (zzCurrentPosL < zzEndReadL)
						zzInput = zzBufferL[zzCurrentPosL++];
					else if (zzAtEOF)
						{
						zzInput = YYEOF;
						goto zzForAction;
						}
					else
						{
						// store back cached positions
						zzCurrentPos = zzCurrentPosL;
						zzMarkedPos = zzMarkedPosL;
						bool eof = zzRefill();
						// get translated positions and possibly new buffer
						zzCurrentPosL = zzCurrentPos;
						zzMarkedPosL = zzMarkedPos;
						zzBufferL = zzBuffer;
						zzEndReadL = zzEndRead;
						if (eof)
							{
							zzInput = YYEOF;
							goto zzForAction;
							}
						else
							zzInput = zzBufferL[zzCurrentPosL++];
						}
					int zzNext = zzTransL[zzRowMapL[zzState] + zzCMapL[zzInput]];
					if (zzNext == -1) 
						goto zzForAction;
					zzState = zzNext;

					int zzAttributes = zzAttrL[zzState];
					if ((zzAttributes & 1) == 1)
						{
						zzAction = zzState;
						zzMarkedPosL = zzCurrentPosL;
						if ((zzAttributes & 8) == 8) 
							goto zzForAction;
						}

					}

zzForAction:
				// store back cached position
				zzMarkedPos = zzMarkedPosL;

				switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction])
					{
					case 12:
						return new Minus();

					case 31: 
						break;
					case 7:
						return new CloseParentheses();

					case 32: 
						break;
					case 3:
						return new IntegerValue(yytext());

					case 33: 
						break;
					case 24:
						return new DoubleValue(yytext());

					case 34: 
						break;
					case 29:
						return new ColumnRange3d(yytext(), externalSheet);

					case 35: 
						break;
					case 4:
						return new RangeSeparator();

					case 36: 
						break;
					case 10:
						return new Divide();

					case 37: 
						break;
					case 25:
						return new CellReference3d(yytext(), externalSheet);

					case 38: 
						break;
					case 26:
						return new BooleanValue(yytext());

					case 39: 
						break;
					case 15:
						return new Equal();
					case 40: break;
					case 17:
							{
							yybegin(YYINITIAL); 
							if (emptyString) 
								return new StringValue("");
							break;
							}
					case 41: 
						break;
					case 8:
						emptyString = true; yybegin(YYSTRING);
						break;

					case 42: 
						break;
					case 21:
						return new NotEqual();

					case 43: 
						break;
					case 22:
						return new LessEqual();

					case 44: 
						break;
					case 16:
						return new LessThan();

					case 45: break;
					case 5:
						return new ArgumentSeparator();

					case 46: 
						break;
					case 30:
						return new Area3d(yytext(), externalSheet);

					case 47: 
						break;
					case 14:
						return new GreaterThan();

					case 48: 
						break;
					case 18:
						return new CellReference(yytext());

					case 49: 
						break;
					case 20:
						return new GreaterEqual();

					case 50: 
						break;
					case 27:
						return new Area(yytext());

					case 51: 
						break;
					case 23:
						return new ColumnRange(yytext());

					case 52: break;
					case 1:
							{
							emptyString = false;
							return new StringValue(yytext());
							}
					case 53: 
						break;
					case 2:
						return new NameRange(yytext(), nameTable);
					case 54: 
						break;
					case 19:
						return new StringFunction(yytext());
					case 55: 
						break;
					case 11:
						return new Plus();
					case 56: 
						break;
					case 28:
						return new ErrorConstant(yytext());
					case 57: 
						break;
					case 9:
						break;
					case 58:
						break;
					case 13:
						return new Multiply();
					case 59:
						break;
					case 6:
						return new OpenParentheses();
					case 60: 
						break;
					default:
						if (zzInput == YYEOF && zzStartRead == zzCurrentPos)
							{
							zzAtEOF = true;
							return null;
							}
						else
							zzScanError(ZZ_NO_MATCH);
						break;
					}
				}
			}
		}
	}
